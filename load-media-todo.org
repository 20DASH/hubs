* feature/load-media
This PR adds a media-loading system to eventually replace the media-loader aframe component.

** TODO Delete, rotate, and scale
** TODO Basic support
Load/spawn all the media types:
*** TODO VIDEO
**** DONE Play the audio
**** DONE Spatialize the audio
**** TODO Re-add support for all the video types (HLS, Dash, hubs://)
**** DONE Make menu
- Make some jsx that makes buttons
- The element we want to mess with is the one that's hovered (and is a video)
- Update the buttons and the slider and stuff depending on the video state
- Make the buttons do the thing to the video
- Maybe parent the menu(?)

**** Fix issue where we can't move videos
*** TODO AUDIO
*** DONE IMAGE
*** TODO PDF
*** DONE MODEL
*** TODO HTML
** DONE Show loading cube while loading
** TODO Restore original pasting action.
** TODO Support pasting files
** TODO Put it behind a feature flag
** TODO New objects need to show up in the object list
** TODO Play loading cube animation
** TODO Alternative loading cubes
** TODO Flat vs 360 projection
** TODO Add physics shapes
*** TODO Physics shape of loading cube
** DONE Resize models on load
** DONE Recenter models
** DONE (mostly) Animate loaded model scale
** TODO Add Object Menus
** TODO Write tests for coroutines
** TODO Pinning
** TODO Do memory audit. What is our footprint?
** TODO Fix scale animate hover thing
** TODO Check that the play/pause video behavior we added for new videos did not mess up aframe videos
** DONE Rename hyphen-ated jsx properties to camelCase
** TODO Think about default props for inflators. We make an empty object. Should it be undefined?
** TODO Think about how uploading a file gives no user feedback until the upload is complete. We can do better than that.

* Stuff
** Do work before render for object loading (upload textures to GPU, etc)

#+begin_src javascript
Upload to GPU

const camera = AFRAME.scenes[0].systems["hubs-systems"].cameraSystem.viewingCamera;
const renderer = AFRAME.scenes[0].renderer;
renderer.render(scene, camera);

renderer.compile(scene, camera);
scene.traverse(obj => {
  if (!obj.material) {
    return;
  }
  const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
  for (const material of materials) {
    for (const prop in material) {
      if (material[prop] && material[prop].isTexture) {
        renderer.initTexture(material[prop]);
      }
    }
  }
});
// HACK
const camera = new THREE.OrthographicCamera();
camera.position.set(0, 0, -50);
renderer.compile(scene, camera);
scene.traverse(obj => {
  if (!obj.material) {
    return;
  }
  const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
  for (const material of materials) {
    for (const prop in material) {
      if (material[prop] && material[prop].isTexture) {
        renderer.initTexture(material[prop]);
      }
    }
  }
});
#+end_src

** useTimeout
*** Similar to useState in react...

#+begin_src javascript

let u;
export const useState = (args) => {
  u(args)
}

const state = {};
function render(foo = SomeBannerInstance) {
  let i=0;
  u = function(initialState) {
    if (!state[foo][i]) {
        state[foo][i] = [initialState, (newState)=>{
        state[foo][i][0] = newState;
      }]
    }

    state[foo][i]
  }
  render(foo)
}
#+end_src

*** Create a contextual, cancelable useTimeout

#+begin_src javascript
function* loadMedia(world, eid) {
  const src = APP.getString(MediaLoader.src[eid]);
  const loadingCubeTimeout = useTimeout(() => {
    const proxy = renderAsEntity(world, LoadingObject());
    add(world, proxy, eid);
  }, 300);
  try {
    const options = yield fetchUrlData(src);
    const media = yield loaderForMediaType[options.mediaType]({ world, ...options });
    clearTimeout(loadingCubeTimeout);
    assignNetworkIds(world, media, eid);
    resizeAndRecenter(world, media, eid);
    removeProxyObject(world, eid);
    add(world, media, eid);
    return media;
  } catch (e) {
    clearTimeout(loadingCubeTimeout);
    removeProxyObject(world, eid);
    add(world, renderAsEntity(world, Cube()), eid);
    throw e;
  }
}
#+end_src

** Use typescript?
https://github.com/mozilla/hubs/compare/master...add-typescript

** Asset preloading

#+begin_src
import { preloads } from "../systems/hubs-systems";
preloads.push(
  loadModel(loadingObjectSrc, null, true).then(gltf => {
    loadingObject = gltf.scene;
  })
);
#+end_src

** Ownership of scene-loaded objects?
      // if explicit vs implicit, choose explicit
      // if both explicit, choose bigger
      // if both implicit, choose smaller.
      //
      // when taking over from an implicit owner,
      // take an explicit opinion
